---
// SVG Elevation Gauge Component
// Displays a vertical gauge with dynamic scale
---

<div class="w-full max-w-lg mx-auto">
  <svg
    id="elevation-gauge"
    viewBox="0 0 200 280"
    class="w-full h-auto drop-shadow-md"
    role="img"
    aria-label="Elevation gauge"
  >
    <!-- Background -->
    <rect x="0" y="0" width="200" height="280" fill="var(--md-sys-color-surface-variant)" rx="8" />

    <!-- Scale lines and labels will be added dynamically -->
    <g id="gauge-scale"></g>

    <!-- Sea level reference line -->
    <line
      id="sea-level-line"
      x1="40"
      x2="170"
      y1="140"
      y2="140"
      stroke="var(--md-sys-color-primary)"
      stroke-width="2"
      stroke-dasharray="4 4"
      opacity="0.6"
    />

    <!-- Indicator marker (animated) - Human icon -->
    <g id="elevation-indicator" transform="translate(80, 140)" opacity="0">
      <!-- Human icon - head -->
      <circle cx="0" cy="-10" r="5" fill="var(--md-sys-color-primary)" stroke="var(--md-sys-color-on-primary)" stroke-width="1.5"/>
      <!-- Human icon - body, arms, legs -->
      <path d="M 0 -5 L 0 5 M -6 0 L 6 0 M 0 5 L -5 12 M 0 5 L 5 12"
            stroke="var(--md-sys-color-primary)"
            stroke-width="3"
            stroke-linecap="round"
            fill="none"/>
    </g>

    <!-- Landmark indicator (to the right of human) -->
    <g id="landmark-indicator" transform="translate(130, 140)" opacity="0">
      <!-- Landmark icon placeholder - will be replaced dynamically -->
      <rect x="-12" y="-12" width="24" height="24" rx="4" fill="var(--md-sys-color-primary)" opacity="0.2"/>
      <text id="landmark-icon-text" x="0" y="5" text-anchor="middle" font-size="16" fill="var(--md-sys-color-primary)">üèî</text>
      <text id="landmark-name-text" x="0" y="22" text-anchor="middle" font-size="8" fill="var(--md-sys-color-on-surface-variant)" opacity="0.9"></text>
    </g>

    <!-- Connection line between human and landmark -->
    <line id="comparison-line" x1="80" y1="140" x2="130" y2="140" stroke="var(--md-sys-color-outline)" stroke-width="1" stroke-dasharray="2 2" opacity="0"/>

    <!-- Center line -->
    <line
      x1="100"
      y1="35"
      x2="100"
      y2="245"
      stroke="var(--md-sys-color-outline)"
      stroke-width="1"
      opacity="0.3"
    />
  </svg>
</div>

<style>
  /* Keep animation styles */
  #elevation-indicator,
  #landmark-indicator {
    transition: transform 500ms cubic-bezier(0.4, 0, 0.2, 1),
                opacity 300ms ease-out;
  }

  #elevation-indicator.active {
    opacity: 1 !important;
  }

  #comparison-line {
    transition: all 500ms cubic-bezier(0.4, 0, 0.2, 1);
  }
</style>

<script>
  interface LandmarkData {
    name: string;
    elevation_meters: number;
    type?: string;
  }

  interface GaugeOptions {
    elevation: number; // in meters
    minElevation?: number;
    maxElevation?: number;
    unit?: 'meters' | 'feet';
    landmark?: LandmarkData;
  }

  class ElevationGauge {
    private svg: SVGElement;
    private indicator: SVGElement;
    private scaleGroup: SVGElement;
    private seaLevelLine: SVGElement;
    private landmarkIndicator: SVGElement;
    private comparisonLine: SVGElement;

    constructor(svgId: string = 'elevation-gauge') {
      this.svg = document.getElementById(svgId) as SVGElement;
      this.indicator = document.getElementById('elevation-indicator') as SVGElement;
      this.scaleGroup = document.getElementById('gauge-scale') as SVGElement;
      this.seaLevelLine = document.getElementById('sea-level-line') as SVGElement;
      this.landmarkIndicator = document.getElementById('landmark-indicator') as SVGElement;
      this.comparisonLine = document.getElementById('comparison-line') as SVGElement;
    }

    /**
     * Update gauge with new elevation
     */
    public update(options: GaugeOptions): void {
      const { elevation, unit = 'meters', landmark } = options;

      // Calculate range (¬±500m window around current elevation)
      const range = 500;
      const minElevation = options.minElevation ?? elevation - range;
      const maxElevation = options.maxElevation ?? elevation + range;

      // Draw scale with unit
      this.drawScale(minElevation, maxElevation, unit);

      // Position sea level line
      this.positionSeaLevel(minElevation, maxElevation);

      // Animate indicator to position
      this.animateIndicator(elevation, minElevation, maxElevation);

      // Position landmark indicator if provided
      if (landmark) {
        this.positionLandmark(landmark, elevation, minElevation, maxElevation);
      }
    }

    /**
     * Draw scale lines and labels
     */
    private drawScale(min: number, max: number, unit: 'meters' | 'feet' = 'meters'): void {
      // Clear existing scale
      this.scaleGroup.innerHTML = '';

      const gaugeHeight = 210; // pixels (from y=35 to y=245)
      const range = max - min;
      const step = this.calculateStep(range);

      // Debug logging
      console.log('Gauge scale:', { min, max, range, step, unit });

      // Round min to nearest step
      const startValue = Math.floor(min / step) * step;
      console.log('Start value:', startValue);

      for (let currentValue = startValue; currentValue <= max; currentValue += step) {
        const value = currentValue;
        const y = this.elevationToY(value, min, max, gaugeHeight);

        // Major tick line
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', '40');
        line.setAttribute('x2', '55');
        line.setAttribute('y1', y.toString());
        line.setAttribute('y2', y.toString());
        line.setAttribute('stroke', 'var(--md-sys-color-outline)');
        line.setAttribute('stroke-width', '1');
        line.setAttribute('opacity', '0.5');
        this.scaleGroup.appendChild(line);

        // Label with correct unit
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', '35');
        text.setAttribute('y', (y + 4).toString());
        text.setAttribute('text-anchor', 'end');
        text.setAttribute('font-size', '12');
        text.setAttribute('fill', '#FFFFFF');
        text.setAttribute('font-weight', '600');
        // Convert to display unit for labels
        const displayValue = unit === 'feet' ? Math.round(value * 3.28084) : Math.round(value);
        const unitLabel = unit === 'feet' ? 'ft' : 'm';
        text.textContent = displayValue.toString() + unitLabel;
        this.scaleGroup.appendChild(text);
      }
    }

    /**
     * Calculate appropriate step size for scale
     */
    private calculateStep(range: number): number {
      if (range <= 100) return 10;
      if (range <= 500) return 50;
      if (range <= 1000) return 100;
      if (range <= 2000) return 200;
      return 500;
    }

    /**
     * Convert elevation value to Y coordinate
     */
    private elevationToY(elevation: number, min: number, max: number, height: number): number {
      const gaugeTop = 35;
      const normalized = (elevation - min) / (max - min);
      return gaugeTop + height - (normalized * height); // Invert (high elevation at top)
    }

    /**
     * Position sea level reference line
     */
    private positionSeaLevel(min: number, max: number): void {
      // Find or create sea level text element
      let seaText = document.getElementById('sea-level-text') as SVGTextElement;

      if (!seaText) {
        seaText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        seaText.id = 'sea-level-text';
        seaText.setAttribute('font-size', '10');
        seaText.setAttribute('fill', 'var(--md-sys-color-on-surface-variant)');
        seaText.setAttribute('opacity', '0.8');
        seaText.textContent = 'Sea';
        this.svg.appendChild(seaText);
      }

      if (min <= 0 && max >= 0) {
        // Sea level is visible in current range
        const y = this.elevationToY(0, min, max, 210);
        this.seaLevelLine.setAttribute('y1', y.toString());
        this.seaLevelLine.setAttribute('y2', y.toString());
        this.seaLevelLine.style.display = 'block';

        // Position text at sea level (0m)
        seaText.setAttribute('x', '175');
        seaText.setAttribute('y', (y + 4).toString());
        seaText.style.display = 'block';
      } else {
        // Sea level not in range
        this.seaLevelLine.style.display = 'none';
        seaText.style.display = 'none';
      }
    }

    /**
     * Animate indicator to position
     */
    private animateIndicator(elevation: number, min: number, max: number): void {
      const y = this.elevationToY(elevation, min, max, 210);

      // Animate human indicator (positioned at x=80)
      this.indicator.setAttribute('transform', `translate(80, ${y})`);
      this.indicator.classList.add('active');
    }

    /**
     * Get emoji icon for landmark type
     */
    private getIconForType(type?: string): string {
      const icons: Record<string, string> = {
        mountain: 'üèî',
        tower: 'üóº',
        building: 'üè¢',
        monument: 'üóø',
        natural: 'üå≤',
        city: 'üèõ',
        structure: 'üåâ',
        site: 'üìç',
      };
      return icons[type || 'site'] || 'üìç';
    }

    /**
     * Position landmark indicator
     */
    private positionLandmark(landmark: LandmarkData, userElevation: number, min: number, max: number): void {
      const landmarkY = this.elevationToY(landmark.elevation_meters, min, max, 210);
      const userY = this.elevationToY(userElevation, min, max, 210);

      // Position landmark indicator at x=130
      this.landmarkIndicator.setAttribute('transform', `translate(130, ${landmarkY})`);
      this.landmarkIndicator.setAttribute('opacity', '1');

      // Update landmark icon and name
      const iconText = this.landmarkIndicator.querySelector('#landmark-icon-text');
      const nameText = this.landmarkIndicator.querySelector('#landmark-name-text');

      if (iconText) {
        iconText.textContent = this.getIconForType(landmark.type);
      }
      if (nameText) {
        // Truncate name if too long
        const shortName = landmark.name.length > 12 ? landmark.name.substring(0, 10) + '...' : landmark.name;
        nameText.textContent = shortName;
      }

      // Draw comparison line between human and landmark
      this.comparisonLine.setAttribute('x1', '80');
      this.comparisonLine.setAttribute('y1', userY.toString());
      this.comparisonLine.setAttribute('x2', '130');
      this.comparisonLine.setAttribute('y2', landmarkY.toString());
      this.comparisonLine.setAttribute('opacity', '0.5');
    }
  }

  // Export for use in main page
  (window as any).ElevationGauge = ElevationGauge;
</script>
